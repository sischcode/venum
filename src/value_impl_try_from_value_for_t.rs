use chrono::{DateTime, FixedOffset, NaiveDate, NaiveDateTime};
use rust_decimal::Decimal;

use crate::errors_result::{ConversionError, Result, VenumError};
use crate::value::Value;
use std::convert::TryFrom;

const VAL_ENUM_NAME: &str = "Value::";

macro_rules! impl_try_from_value_for_type {
    ($enum_type:ident, $for_type:ty) => {
        impl TryFrom<Value> for $for_type {
            type Error = VenumError;
            fn try_from(item: Value) -> Result<Self> {
                match item {
                    Value::$enum_type(v) => Ok(v),
                    _ => Err(VenumError::Conversion(ConversionError::WrongType {
                        src_value: format!("{:?}", item), // i.e. Bool(true)
                        src_type: format!("{}{}", VAL_ENUM_NAME, item), // i.e. Value::Bool, where 'Bool' is generated by strum through the display trait
                        target_type: String::from(stringify!($for_type)),
                        details: None,
                    })),
                }
            }
        }
    };
}
impl_try_from_value_for_type!(Char, char);
// impl_try_from_value_for_type!(String, String); // implemented below, because we handle Value::None differently here! // TODO: not sure, if this is a good idea, though)
impl_try_from_value_for_type!(Int8, i8);
impl_try_from_value_for_type!(Int16, i16);
impl_try_from_value_for_type!(Int32, i32);
impl_try_from_value_for_type!(Int64, i64);
impl_try_from_value_for_type!(Int128, i128);
impl_try_from_value_for_type!(UInt8, u8);
impl_try_from_value_for_type!(UInt16, u16);
impl_try_from_value_for_type!(UInt32, u32);
impl_try_from_value_for_type!(UInt64, u64);
impl_try_from_value_for_type!(UInt128, u128);
impl_try_from_value_for_type!(Float32, f32);
impl_try_from_value_for_type!(Float64, f64);
impl_try_from_value_for_type!(Bool, bool);
impl_try_from_value_for_type!(Decimal, Decimal);
impl_try_from_value_for_type!(NaiveDate, NaiveDate);
impl_try_from_value_for_type!(NaiveDateTime, NaiveDateTime);
impl_try_from_value_for_type!(DateTime, DateTime<FixedOffset>);

impl TryFrom<Value> for String {
    type Error = VenumError;
    fn try_from(item: Value) -> Result<Self> {
        match item {
            Value::String(v) => Ok(v),
            Value::None => Ok(String::new()),
            _ => Err(VenumError::Conversion(ConversionError::WrongType {
                src_value: format!("{:?}", item),               // i.e. Bool(true)
                src_type: format!("{}{}", VAL_ENUM_NAME, item), // i.e. Value::Bool, where 'Bool' is generated by strum through the display trait
                target_type: String::from("String"),
                details: None,
            })),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn impl_try_from_value_for_type() {
        assert_eq!(
            String::from("foobar"),
            String::try_from(Value::String(String::from("foobar"))).unwrap()
        );
        assert_eq!(
            String::new(),
            String::try_from(Value::String(String::from(""))).unwrap()
        );
        assert_eq!(String::new(), String::try_from(Value::None).unwrap());

        assert_eq!('a', char::try_from(Value::Char('a')).unwrap());

        assert_eq!(0i8, i8::try_from(Value::Int8(0i8)).unwrap());
        assert_eq!(0i16, i16::try_from(Value::Int16(0i16)).unwrap());
        assert_eq!(0i32, i32::try_from(Value::Int32(0i32)).unwrap());
        assert_eq!(0i64, i64::try_from(Value::Int64(0i64)).unwrap());
        assert_eq!(0i128, i128::try_from(Value::Int128(0i128)).unwrap());

        assert_eq!(0u8, u8::try_from(Value::UInt8(0u8)).unwrap());
        assert_eq!(0u16, u16::try_from(Value::UInt16(0u16)).unwrap());
        assert_eq!(0u32, u32::try_from(Value::UInt32(0u32)).unwrap());
        assert_eq!(0u64, u64::try_from(Value::UInt64(0u64)).unwrap());
        assert_eq!(0u128, u128::try_from(Value::UInt128(0u128)).unwrap());

        assert_eq!(0.0f32, f32::try_from(Value::Float32(0.0f32)).unwrap());
        assert_eq!(0.0f64, f64::try_from(Value::Float64(0.0f64)).unwrap());

        assert_eq!(true, bool::try_from(Value::Bool(true)).unwrap());

        assert_eq!(
            Decimal::new(00, 1),
            Decimal::try_from(Value::Decimal(Decimal::new(00, 1))).unwrap()
        );

        assert_eq!(
            NaiveDate::from_ymd_opt(2022, 12, 31).unwrap(),
            NaiveDate::try_from(Value::NaiveDate(
                NaiveDate::from_ymd_opt(2022, 12, 31).unwrap()
            ))
            .unwrap()
        );
        assert_eq!(
            NaiveDate::from_ymd_opt(2022, 12, 31)
                .unwrap()
                .and_hms_opt(12, 00, 00)
                .unwrap(),
            NaiveDateTime::try_from(Value::NaiveDateTime(
                NaiveDate::from_ymd_opt(2022, 12, 31)
                    .unwrap()
                    .and_hms_opt(12, 00, 00)
                    .unwrap()
            ))
            .unwrap()
        );

        let dt = NaiveDate::from_ymd_opt(2022, 12, 31)
            .unwrap() // This date exists for sure. Unwrap is safe here
            .and_hms_milli_opt(6, 0, 0, 0)
            .unwrap() // This time exists for sure. Unwrap is safe here
            .and_local_timezone(FixedOffset::east_opt(5 * 3600).unwrap()) // east = +; west = -
            .unwrap(); // This timezone (UTC) exists for sure. Unwrap is safe here

        assert_eq!(dt, DateTime::try_from(Value::DateTime(dt)).unwrap());
    }

    #[test]
    #[should_panic(
        expected = "Conversion(WrongType { src_value: \"Int8(0)\", src_type: \"Value::Int8\", target_type: \"bool\", details: None })"
    )]
    pub fn string_to_bool_err() {
        bool::try_from(Value::Int8(0i8)).unwrap();
    }
}
